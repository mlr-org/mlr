# Learning Tasks

Learning tasks encapsulate the data set and further relevant information about a machine
learning problem, for example the name of the target variable.


## Task types and creation

The tasks are organised in a hierarchy, with the generic [&Task] at the top.
The following tasks can be instantiated and all inherit from a virtual superclass [&Task]:

* [ClassifTask](&Task) for binary and multi-class classification problems,
* [RegrTask](&Task) for regression problems,
* [SurvTask](&Task) for survival analysis,
* [CostSensTask](&Task) for cost-sensitive classification,
* [ClusterTask](&Task) for cluster analysis.

To create a task, just call ``make<TaskType>``, e.g., [makeClassifTask](&Task).
All tasks require an identifier (argument ``id``) and a [data frame](&base::data.frame) (argument ``data``).
If no ID is provided it is automatically generated using the name of the data.
It will be later used to name results, for example of
[benchmark experiments](benchmark_experiments.md).
Depending on the nature of the learning problem, additional arguments may be required and
are exemplified in the following subsections.


### Cluster analysis

Because cluster analysis is unsupervised, the only mandatory argument to construct a cluster analysis task is the ``data``.
In the following example we create a learning task from the data set [mtcars](&datasets::mtcars).

```{r}
data(mtcars, package = "datasets")
cluster.task = makeClusterTask(data = mtcars)
cluster.task
```


### Regression

For supervised learning like regression (as well as classification and
survival analysis) we, in addition to ``data``, have to specify the name of the ``target``
variable.

```{r}
data(BostonHousing, package = "mlbench")
regr.task = makeRegrTask(id = "bh", data = BostonHousing, target = "medv")
regr.task
```

As you can see, the [&Task] records the type of the learning problem and basic information about
the data set, e.g., the types of the features (numeric vectors, factors or ordered factors),
the number of observations, or whether missing values are present.

Creating tasks for classification problems and survival analysis follows the same scheme,
except the type of the target variables.
For each of these learning problems, some specifics are described below.


### Classification

For classification the target variable has to be a [factor](&base::factor).

In binary classification it is customary to refer to the two classes as *positive* and
*negative* class.
This is for example relevant with regard to certain [performance measures](performance.md)
like the *true positive rate*.
By default the first factor level of the target variable is selected as the positive class.

In the following example, we define a classification task for the
[BreastCancer](&mlbench::BreastCancer) data set and exclude the variable ``Id`` from all further
model fitting and evaluation.

```{r}
data(BreastCancer, package = "mlbench")
df = BreastCancer
df$Id = NULL
classif.task = makeClassifTask(id = "BreastCancer", data = df, target = "Class")
classif.task
```

The positive class is benign.
Class malignant can be manually selected as the positive class:

```{r}
classif.task = makeClassifTask(id = "BreastCancer", data = df, target = "Class",
  positive = "malignant")
```


### Survival analysis

Survival tasks use two target columns.
For left and right censored problems these consist of the survival time and a binary event indicator.
For interval censored data the two target columns must be specified in the ``"interval2"`` format (see [Surv](&survival::Surv)).

```{r}
data(lung, package = "survival")
lung$status = (lung$status == 2) # convert to logical
surv.task = makeSurvTask(data = lung, target = c("time", "status"))
surv.task
```

The type of censoring can be specified via the argument ``censoring`` which defaults to
``"rcens"`` for right censored data.


### Cost-sensitive classification

The standard objective in classification is to obtain a high prediction accuracy, i.e., to
minimize the number of errors. Thereby, all types of misclassification errors are deemed
equally severe. However, in many applications different kinds of errors cause different costs
that should be taken into consideration.

There exist different types of misclassification costs.
In case of *class-dependent costs* that depend on the actual and predicted class labels it
is sufficient to create an ordinary [ClassifTask](&Task).

In order to handle *example-specific costs* it is necessary to generate a [CostSensTask](&Task).
In this scenario, each example (*x*, *y*) is associated with an individual cost vector of length
*K* where *K* denotes the number of classes. The *k*-th component indicates the cost of assigning
*x* to class *k*. Naturally, it is assumed that the cost of the intended class label *y* is
minimal.

As the cost vector contains all relevant information about the intended class label *y*, only
the feature values *x* and a ``cost`` matrix that contains the cost vectors for all examples in the data
set are required to create the [CostSensTask](&Task).

In the following example we use the [iris data](&datasets::iris) and generate an artificial cost matrix
(following [Beygelzimer et al. (2005)](http://dx.doi.org/10.1145/1102351.1102358)):

```{r}
df = iris
cost = matrix(runif(150 * 3, 0, 2000), 150) * (1 - diag(3))[df$Species,]
df$Species = NULL

costsens.task = makeCostSensTask(data = df, cost = cost)
costsens.task
```

For more details see the section about [cost-sensitive classification](cost_sensitive_classif.md).


### Further details

The [&Task] help page also lists several other arguments to describe further details of the
problem.

For example, we could include a ``blocking`` factor into the task.
This would tell the task that some observations "belong together", and should
not be separated when splitting into training and test sets during a resampling iteration.

Another possibility is to assign ``weights`` to observations according to their importance.


## Accessing a learning task

The [&Task] object is a [list](base::list) and its main properties are stored in element
``$task.desc`` which is of class [&TaskDesc].

```{r}
str(regr.task$task.desc)
```

Moreover, there are some functions, following the naming convention
``getTask<what_to_extract>``, to access the [&Task] and the encapsulated data.
The most important ones are listed in the documentation of [&Task].
Here are some examples.

```{r}
## Get the number of input variables in cluster.task:
getTaskNFeats(cluster.task)

## Get the names of the input variables in cluster.task:
getTaskFeatureNames(cluster.task)

## Get the names of the target columns:
getTaskTargetNames(surv.task)

## Get the values of the target variable in regr.task:
head(getTaskTargets(regr.task))

## Get the cost matrix in costsens.task:
head(getTaskCosts(costsens.task))

## Accessing the data set in classif.task:
str(getTaskData(classif.task))
```

Note the many options [&getTaskData] provides to convert the data set into a convenient format.
This especially comes in handy when you [integrate a learner](create_learner.md) from another **R**
package into [%mlr].
In this regard the functions [&getTaskFormula] and [getTaskFormulaAsString](&getTaskFormula)
are also useful.


## Modifying a learning task

[%mlr] provides several functions to alter an existing [&Task] which is often more
convenient than creating a new [&Task] from scratch.
Here are some examples.

```{r}
## Select observations and features:
cluster.task = subsetTask(cluster.task, subset = 4:17)

## It may happen, especially after selecting observations, that features are constant.
## These should be removed.
removeConstantFeatures(cluster.task)

## Remove selected features:
dropFeatures(surv.task, c("meal.cal", "wt.loss"))

## Standardize numerical features:
normalizeFeatures(classif.task, method = "standardize")
```

For more information see also the section about [data preprocessing](preproc.md).


## Example tasks

For your convenience [%mlr] provides pre-defined [&Task]s for each type of learning problem.
These are used throughout this tutorial in order to get shorter and more readable code.
A list of all [&Task]s can be found [here](example_tasks.md).

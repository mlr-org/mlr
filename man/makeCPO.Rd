% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CPO.R, R/CPOTarget.R
\name{makeCPO}
\alias{makeCPO}
\alias{makeCPOTargetOp}
\title{Create a custom CPO constructor}
\usage{
makeCPO(.cpo.name, ..., .par.set = NULL, .par.vals = list(),
  .datasplit = c("target", "most", "all", "no", "task", "factor",
  "onlyfactor", "ordered", "numeric"), .retrafo.format = c("separate",
  "combined", "stateless"), .export.params = TRUE, .fix.factors = FALSE,
  .properties = c("numerics", "factors", "ordered", "missings"),
  .properties.adding = character(0), .properties.needed = character(0),
  .properties.target = c("cluster", "classif", "multilabel", "regr", "surv",
  "oneclass", "twoclass", "multiclass", "lcens", "rcens", "icens"),
  .packages = character(0), cpo.trafo, cpo.retrafo)

makeCPOTargetOp(.cpo.name, ..., .par.set = NULL, .par.vals = list(),
  .datasplit = c("target", "most", "all", "no", "task", "factor",
  "onlyfactor", "ordered", "numeric"), .data.dependent = TRUE,
  .retrafo.format = c("separate", "combined", "stateless"),
  .export.params = TRUE, .properties.data = c("numerics", "factors",
  "ordered", "missings"), .properties.adding = character(0),
  .properties.needed = character(0), .properties.target = character(0),
  .type = c("cluster", "classif", "multilabel", "regr", "surv"),
  .type.out = .type, .predict.type = c(response = "response"),
  .packages = character(0), cpo.trafo, cpo.retrafo)
}
\arguments{
\item{.cpo.name}{[\code{character(1)}]\cr
The name of the resulting CPO constructor / CPO. This is used for identification in output,
and as the default \code{id}.}

\item{...}{Parameters of the CPO, in the format of \code{\link{paramSetSugar}}.}

\item{.par.set}{[\code{ParamSet}]\cr
Optional parameter set. If this is not \code{NULL}, the \dQuote{...} parameters are ignored.
Default is \code{NULL}.}

\item{.par.vals}{[\code{list}]\cr
Named list of default parameter values for the CPO. These are used additionally to the
parameter default values in \dQuote{...} and \code{.par.set}. It is preferred to use
these default values, and not \code{.par.vals}. Default is \code{list()}.}

\item{.datasplit}{[\code{character(1)}]\cr
  Indicate what format the data should be as seen by \dQuote{cpo.trafo} and \dQuote{cpo.retrafo}. Possibilities are:
  \itemize{
    \item{\bold{target}} the \dQuote{data} variable contains the data as a data.frame without
      the target column(s), the \dQuote{target} variable contains the target column(s) as
      a data.frame.
    \item{\bold{no}} the \dQuote{data} variable contains a data.frame with all data, the \dQuote{target}
      variable is a \code{character} indicating the names of the target columns.
    \item{\bold{task}} the \dQuote{data} variable contains the data as a \dQuote{\link{Task}}.
    \item{\bold{most}} the \dQuote{data} is a named list containing three data.frames: \dQuote{numeric}
      the numeric columns, \dQuote{factor} the factorial columns (ordered and unordered),
      \dQuote{other} the columns that are neither numeric nor factors. The \dQuote{target}
      variable contains the target column(s) as a data.frame.
    \item{\bold{all}} similarly to \dQuote{most}, but factors are additionally split up into \dQuote{factor}
      (unordered factors) and \dQuote{ordered}.
    \item{\bold{factor}} similar to \dQuote{target}, but \dQuote{data} will only contain the features
      that are either of type \dQuote{factor} or \dQuote{ordered}.
    \item{\bold{onlyfactor}} similar to \dQuote{target} but \dQuote{data} will only contain the features
      that are of type \dQuote{factor}.
    \item{\bold{ordered}} similar to \dQuote{target} but \dQuote{data} will only contain the features
      that are of type \dQuote{ordered}.
    \item{\bold{numeric}} similar to \dQuote{target} but \dQuote{data} will only contain the features
      that are of type \dQuote{numeric}.
  }

  If the CPO is a Target Operation CPO, the return value of both \dQuote{cpo.trafo} and \dQuote{cpo.retrafo}
  must be either a task if \code{.datasplit} is \dQuote{task}, the complete (modified) data.frame
  if \code{.datasplit} is \dQuote{no}, and a data.frame containing only the target column(s) otherwise.
  Default is \dQuote{target}.

  If the CPO is a Feature Operation CPO, then the return value must be in the same format as the one requested.
  E.g. if \code{.datasplit} is \dQuote{most}, the return value must be a named list with entries \dQuote{numeric},
  \dQuote{factor}, and \dQuote{other}. The types of the returned data may be arbitrary: In the given example,
  the \dQuote{factor} slot of the returned list may contain numeric data. (Note however that if data is returned
  that has a type not already present in the data, \dQuote{.properties.needed} must specify this.)

  If \code{.datasplit} is either \dQuote{no} or \dQuote{task}, the
  target column(s) in the returned value must be identical with the target column(s) given as input.

  If \dQuote{.datasplit} is \dQuote{most} or \dQuote{all}, the \dQuote{$numeric} slot of the returned
  object may also be a \code{matrix}. If \dQuote{.datasplit} is \dQuote{numeric}, the returned object may also be a
  matrix.}

\item{.retrafo.format}{[\code{character(1)}]\cr
Indicates what API is used for \code{cpo.trafo} and \code{cpo.retrafo}, and how state information is transferred
between them. Possibilities are:
\itemize{
  \item{separate} \code{cpo.trafo} must be specified and is called with the training data and the CPO parameters.
    It must return the modified data, and within its namespace must either specify a \dQuote{control} variable ("Object-Based CPO"),
    if \code{cpo.retrafo} is given, or a \dQuote{cpo.retrafo} variable, if (the makeCPO parameter) \code{cpo.retrafo}
    is \code{NULL} ("Functional CPO"). For Object-Based CPO, \code{cpo.retrafo} is called with the \code{control} object
    created in \code{cpo.trafo}, additionally with the new data, and the CPO parameters. For Functional CPO, \code{cpo.retrafo} is
    constructed inside the \code{cpo.trafo} call and is used for transformation of new data. It must take a single argument and
    return the transformed data.
  \item{combined} \code{cpo.trafo} must be specified and is called with the training data and the CPO parameters. It must return
    a \code{cpo.retrafo} function that takes the data to be transformed as a single argument, and returns the transformed data.
    If \code{.retrafo.format} is \dQuote{combined}, \code{pco.retrafo} must be \code{NULL}.
  \item{stateless} Specification of \code{cpo.trafo} is optional and may be \code{NULL}. If it is not given, \code{cpo.retrafo} is used on both
    training and new data; otherwise, \code{cpo.trafo} is applied to training data, \code{cpo.retrafo} is used on predict data. There
    is no transfer of information from trafo to retrafo. If \code{cpo.trafo} is not given, \code{.datasplit} must not be \dQuote{task} or \dQuote{no}.
}}

\item{.export.params}{[\code{logical(1)} | \code{character}]\cr
Indicates which CPO parameters are exported by default. Exported parameters can be changed after construction using \code{\link{setHyperPars}},
but exporting too many parameters may lead to messy parameter sets if many CPOs are combined. This can be overridden on construction.
If this is a \code{logical(1)}, \code{TRUE} exports all parameters, \code{FALSE} to exports no parameters. It may also be a \code{character},
indicating the names of parameters to be exported. Default is \code{TRUE}.}

\item{.fix.factors}{[\code{logical(1)}]\cr
Whether to constrain factor levels of new data to the levels of training data, for each factorial or ordered column. If new data contains
factors that were not present in training data, the values are set to \code{NA}. Default is \code{FALSE}.}

\item{.properties}{[\code{character}]\cr
The kind if data that the CPO will be able to handle. This can be one or many of: \dQuote{numerics},
\dQuote{factors}, \dQuote{ordered}, \dQuote{missings}.
There should be a bias towards including properties. If a property is absent, the preproc
operator will reject the data. If an operation e.g. only works on numeric columns that have no
missings (like PCA), it is recommended to give all properties, ignore the columns that
are not numeric (using \dQuote{.datasplit} = \dQuote{most}), and giving an error when
there are missings in the numeric columns (since missings in factorial features are not a problem).
Defaults to the maximal set.}

\item{.properties.adding}{[\code{character}]\cr
Can be one or many of the same values as \dQuote{.properties} for Feature Operation CPOs, and one or many of the same values as \dQuote{.properties.target}
for Target Operation CPOs. These properties get added to a Learner (or CPO) coming after / behind this CPO. When a CPO imputes missing values, for example,
this should be \dQuote{missings}. This must be a subset of \dQuote{.properties} or \dQuote{.properties.target}. Default is
\code{character(0)}.}

\item{.properties.needed}{[\code{character}]\cr
Can be one or many of the same values as \dQuote{.properties} for Feature Operation CPOs,
and one or many of the same values as \dQuote{.properties.target}. These properties are required
from a Learner (or CPO) coming after / behind this CPO. E.g., when a CPO converts factors to
numerics, this should be \dQuote{numerics} (and \dQuote{.properties.adding} should be \dQuote{factors}).
Default is \code{character(0)}.}

\item{.properties.target}{[\code{character}]\cr
  For Feature Operation CPOs, this can be one or many of \dQuote{cluster}, \dQuote{classif}, \dQuote{multilabel}, \dQuote{regr}, \dQuote{surv},
  \dQuote{oneclass}, \dQuote{twoclass}, \dQuote{multiclass}. Just as \code{.properties}, it
  indicates what kind of data a CPO can work with. Data given as data.frame needs the \dQuote{cluster} property. Default is the maximal set.

  For Target Operation CPOs, this should only be given if the CPO operates on classification tasks. It must then be a subset of \dQuote{oneclass},
  \dQuote{twoclass}, or \dQuote{multiclass}. Otherwise, it should be \code{character(0)}. Default is \code{character(0)}.}

\item{.packages}{[\code{character}]\cr
Package(s) that should be loaded when the CPO is constructed. This gives the user an early error if
a package required for the CPO is not available on his system, or can not be loaded. Default is \code{character(0)}.}

\item{cpo.trafo}{[\code{language} | \code{function} | \code{NULL}]\cr
  This can either be a function, or just the function body wrapped in curly braces.
  If this is a function, it must have the parameters \dQuote{data} and \dQuote{target},
  as well as the parameters specified in \dQuote{...} or \dQuote{.par.set}. (Alternatively,
  the function may have a dotdotdot argument). Depending on the values of \code{.retrafo.format} and
  \code{.datasplit} -- see there --, it must return a \dQuote{data.frame}, a \dQuote{task},
  a dQuote{matrix}, \dQuote{list} of \dQuote{data.frame} and \dQuote{matrix} objects, or a retrafo function.

  If \dQuote{cpo.retrafo} is given and \code{.retrafo.format} is \dQuote{separate}, it must create a \dQuote{control}
  variable in its namespace, which will be passed on to \dQuote{cpo.retrafo}. If \dQuote{cpo.retrafo} is
  not given and \code{.retrafo.format} is \dQuote{separate}, it must create a \dQuote{cpo.retrafo} function within its namespace, which will be called
  for re-transformation.

  If \code{.retrafo.format} is \dQuote{combined}, this function must return a \dQuote{cpo.retrafo} function.

  If \code{.retrafo.format} is
  \dQuote{stateless}, this argument may be \code{NULL}, or a function which just returns the transformed data.

  If \dQuote{cpo.trafo} is a list of expressions (preferred), it is turned into a function by mlr, with the correct function arguments.}

\item{cpo.retrafo}{[\code{language} | \code{function}]\cr
Similarly to \dQuote{cpo.trafo}, this is either a function, the function body in curly braces (preferred), or \code{NULL}.
If this is not \code{NULL}, this function must have the same arguments as \code{cpo.trafo}, with the exception that
the \dQuote{target} argument is replaced by a \dQuote{control} argument, which will be
the value created in the \dQuote{cpo.trafo} run. It gets its input data in the same format as
\dQuote{cpo.trafo}, with the exception that if \dQuote{.datasplit} is \dQuote{task}, it gets a
\dQuote{data.frame} as if \dQuote{.datasplit} were \dQuote{no}. This function must similarly return an
object in the same format as it received as input.}

\item{.type}{[\code{character(1)}]\cr
For Target Operation CPOs, the type of task that it operates on. Must be one of \dQuote{cluster}, \dQuote{classif}, \dQuote{multilabel}, \dQuote{regr},
or \dQuote{surv}. If input data is a data.frame, it will be treated as a cluster task. Default is \dQuote{cluster}.}

\item{.type.out}{[\code{character(1)}]\cr
For Target Operation CPOs, the type of task that will be generated by this CPO. If this is the same as \code{.type}, no conversion takes place.
Possible values are the same as for \code{.type}. Default is \code{.type}.}

\item{.predict.type}{[\code{character} | \code{list}]\cr
Must be a named \code{character}, or named \code{list} of \code{character(1)}, indicating
what \code{predict.type} (see \link{Prediction}) a prediction must have if the output prediction
is to be of some type. E.g. if a CPO converts a \dQuote{regr} \code{Task} into a
\dQuote{classif} \code{Task}, and if for \dQuote{se} prediction it needs a classification
learner to give \dQuote{prob} type predictions, while for \dQuote{response} prediction it
also needs \dQuote{response} predictions, this would be \code{c(response = "response",
se = "prob")}. The names are the prediction types that are requested from this CPO, the
values are types that this CPO will request from an underlying learner. If a name is not
present, the \code{predict.type} is assumed not supported. Default is \code{c(response = "response")}.}
}
\description{
\code{makeCPO} creates a Feature Operation CPO constructor, i.e. a constructor for a CPO that will
operate on feature columns. \code{makeCPOTargetOp} creates a Target Operation CPO constructor, which
creates CPOs that operate on the target column.
}
\examples{
# an example 'pca' CPO
# demonstrates the (object based) "separate" CPO API
pca = makeCPO("pca",  # name
  center = TRUE: logical,  # one logical parameter 'center'
  .datasplit= "numeric",  # only handle numeric columns
  .retrafo.format = "separate",  # default, can be omitted
  # cpo.trafo is given as a function body. The function head is added
  # automatically, containing 'data', 'target', and 'center'
  # (since a 'center' parameter was defined)
  cpo.trafo = {
    pcr = prcomp(as.matrix(data), center = center)
    # The following line creates a 'control' object, which will be given
    # to retrafo.
    control = list(rotation = pcr$rotation, center = pcr$center)
    pcr$x  # returning a matrix is ok
  # Just like cpo.trafo, cpo.retrafo is a function body, with implicit
  # arguments 'data', 'control', and 'center'.
  }, cpo.retrafo = {
    scale(as.matrix(data), center = control$center, scale = FALSE) \%*\%
      control$rotation
  })

# an example 'scale' CPO
# demonstrates the (functional) "separate" CPO API
scaleCPO = makeCPO("scale",
  .datasplit = "numeric",
  # .retrafo.format = "separate" is implicit
  cpo.trafo = function(data, target) {
    result = scale(as.matrix(data), center = center, scale = scale)
    cpo.retrafo = function(data) {
      # here we can use the 'result' object generated in cpo.trafo
      scale(as.matrix(data), attr(result, "scaled:center"),
        attr(result, "scaled:scale"))
    }
    result
  }, cpo.retrafo = NULL)  # don't forget to set it cpo.retrafo to NULL

# an example constant feature remover CPO
# demonstrates the "combined" CPO API
constFeatRem = makeCPO("constFeatRem",
  .datasplit = "target",
  .retrafo.format = "combined",
  cpo.trafo = function(data, target) {
    cols.keep = names(Filter(function(x) {
        length(unique(x)) > 1
      }, data))
    # the following function will do both the trafo and retrafo
    result = function(data) {
      data[cols.keep]
    }
    result
  }, cpo.retrafo = NULL)

# an example 'square' CPO
# demonstrates the "stateless" CPO API
square = makeCPO("scale",
  .datasplit = "numeric",
  .retrafo.format = "stateless",
  cpo.trafo = NULL, # optional, we don't need it since trafo & retrafo same
  cpo.retrafo = function(data) {
    as.matrix(data) * 2
  })

}
\seealso{
Other CPO: \code{\link{CPOImputer}}, \code{\link{CPO}},
  \code{\link{NULLCPO}}, \code{\link{\%>>\%}},
  \code{\link{applyCPO}}, \code{\link{attachCPO}},
  \code{\link{chainCPO}}, \code{\link{cpoApplyFun}},
  \code{\link{cpoApply}}, \code{\link{cpoAsNumeric}},
  \code{\link{cpoCollapseFact}},
  \code{\link{cpoDropConstants}},
  \code{\link{cpoDummyEncode}},
  \code{\link{cpoFilterFeatures}},
  \code{\link{cpoFixFactors}},
  \code{\link{cpoImpactEncodeClassif}},
  \code{\link{cpoImpactEncodeRegr}},
  \code{\link{cpoImpute}},
  \code{\link{cpoMissingIndicators}},
  \code{\link{cpoModelMatrix}}, \code{\link{cpoMultiplex}},
  \code{\link{cpoPca}}, \code{\link{cpoProbEncode}},
  \code{\link{cpoQuantileBinNumerics}},
  \code{\link{cpoScaleMaxAbs}},
  \code{\link{cpoScaleRange}}, \code{\link{cpoScale}},
  \code{\link{cpoSelect}}, \code{\link{cpoSpatialSign}},
  \code{\link{getCPOAffect}}, \code{\link{getCPOId}},
  \code{\link{getCPOName}}, \code{\link{getHyperPars}},
  \code{\link{getRetrafoState}},
  \code{\link{hasTagInvert}}, \code{\link{inverter<-}},
  \code{\link{inverter}},
  \code{\link{makeRetrafoFromState}},
  \code{\link{retrafo<-}}, \code{\link{retrafo}},
  \code{\link{setCPOId}}, \code{\link{setHyperPars}},
  \code{\link{tagInvert}}
}
